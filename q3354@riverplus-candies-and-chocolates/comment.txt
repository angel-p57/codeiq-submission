まず F(n,k)=G(n,k) である。そのため、2F(n,k)を計算するコードを実装した

なぜ、F,Gが等しくなるかについては、
例えば、10個のブロックを、左端を揃えて3段につむ ( 穴あきはなし ) ことを考えると、

□□
□□□
□□□□□

横方向に切れば、大きい順に5,3,2の3個の塊に分ける方法に対応し、
縦方向に切れば、3,3,2,1,1 と複数の塊 ( 最大3 ) に分ける方法に対応するからである

つまり、F,G はそれぞれ、同じ積み方を異なる分け方で区別して数えているに過ぎない

さて、F の方で考えると
　F(n,k)=0 ( n＜k )
　F(1,1)=1 
　F(n,k)=Σ[j=1,k] F(n-k,j)
が漸化式で、まとめ直すと F(n,k)=F(n-1,k-1)+F(n-k,k)

ここから、F(n,k)=H(n-k,k) として定義したHの方で計算する
　H(n,k)=0 ( n＜0 )
　H(n,1)=1
　H(n,k)=H(n,k-1)+H(n-k,k) ( k＞1 )
ということで、n-k-1要素のバッファを一番下の漸化式に伴い k-1回更新することで、
最終的な F(n,k)=H(n-k,k) を得る

結果としてRuby(85)で、恐らく再帰で書くよりも僅かに短い感じになる
